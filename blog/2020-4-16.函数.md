---
id: 函数
title: 函数
author: 李川
author_title: 随便写写
author_url: https://github.com/newlichuan
author_image_url: /img/logo.jpg
---

#### JS 中最核心的东西,函数....

<!--truncate-->

JS 虽然是多范式的编程语言,但是其面向对象支持的并不是很好,  
反而函数是一等公民这个特性,使得偏向函数式编程,但不是纯粹的函数式编程,毕竟我们会有副作用的

## 什么是函数

函数,或者方法都是同一个概念  
是一个可重复执行的代码段,接收输入和返回输出
js 中的函数也是特殊的 object 类型
但是 typeof 返回时 "function"

## 函数是一等公民

一等公民什么概念呢,就是函数可以被当做一个值来看待,

```js
const func = function () {};
```

这意味巨大的灵活性

1. 函数可以存入变量
2. 函数可以当做函数的参数
3. 函数可以返回函数
4. 函数内可以创建函数
5. 函数内可以调用其他函数
6. 函数调用就是一个表达式,返回值就是函数的返回值
7. 函数身上可以有属性,因为函数也是对象

## 创建函数

### 普通函数

#### 函数声明

```js
function func(a, b) {
  return a + b;
}
```

这种创建方法叫做函数声明,会有函数提升现象发生,就是再作用域第一行已经可以使用了  
函数名是必须的, 参数或者返回值可以省略 没有 return 时返回 undefined

#### 函数表达式

```js
const func = function () {};
```

这种通过一个变量接收 属于函数表达式,没有提升现象. 更能清楚的表示出函数就是一个值得现象  
函数表达式可以省略函数名

### 箭头函数

es6 新增,只能通过函数表达式创建,并且只能是匿名的

```js
const func = () => {};
```

## 函数参数

### 形参

形参就是定义时, 需要接受值得变量名,在函数体内可以调用形参值

```js
const func = a => console.log(a);
```

### 实参

函数调用时传递的值,按形参定义的位置传递

```js
fun(1); //1
```

### 实参数量

js 没有规定实际传递的参数要跟形参一致,多传会被忽略,少传的值为 undefined

### 剩余参数

函数获得此次传递的所有参数,相当于函数的重载,就是可以根据不同的参数执行不同的行为
es5 一般是用 arguments 对象,这是个伪数组,但是有遍历接口,  
可以使用 for of 遍历 如果需要使用数组方法,可以使用展开语法转换为数组

```js
const func = function () {
  console.log(arguments);
  for (let s of arguments) {
    console.log(s);
  }
  let a = [...arguments];
  Array.isArray(a); // true
};
func(1, 2, 3, 4);
```

由于箭头函数没有这个参数,而且现在也不推荐这么做了,可以使用 es6 新增的 rest 参数

```js
const func = (...rest) => console.log(rest);
func(1, 2, 3, 4); // [1,2,3,4]
```

三个点后跟一个形参名,表式将剩余的所有参数打包为一个数组,  
必须在最后一个参数

### 参数默认值

es6 新增 ,表示某个形参的值为 undefined 时,默认的值

```js
const func = (a = 123) => console.log(a);
func(); // 123
```

当参数 a 没传,或者值是 undefined 时会用默认值,
这里有个注意点,**就是使用了参数默认值,参数会形成一个单独的作用域**

### 参数解构

因为传参本身就是值传递,跟变量赋值是一个性质  
所以可以使用 es6 的解构语法

```js
const func = ([a, b, c]) => {
  console.log(a, b, c);
};
func([1, 2, 3]); // 1,2,3
```

解构对象也是可以的

```js
const func = ({ a, b }) => {
  console.log(a, b);
};
func({ a: 1, b: 2 });
```

**解构对象可以实现参数不必按顺序传递**,也不会造成不传的参数必须传 undefined
解构可以和默认值一起使用,双重默认值

```js
const func = ({ a = 123 } = {}) => {
  console.log(a);
};
func(); //123;
```

## 函数返回值

使用 return 返回一个单个值(或者一个表达式),return 会终止函数的运行

## 函数 name 属性

函数名字方便在函数内调用自身  
方便调试的时候查看调用栈,js 会算出函数 name 名字,有以下规则

1. 函数直接声明,name 属性就是函数名

```js
functio func(){};
console.log(func.name);//func
```

2. 函数表达式,函数名为变量名

```js
const func = () => {};
console.log(func.name); // func
```

3. 具名函数表达式和变量都有,此时名字为函数的名字

```js
const func = function func1() {};
console.log(func.name); // func1
```

这么写是有必要的,比如这个函数被赋值给另一个变量,此时这个名字  
是不会变的,永远可以调用自身

4. bind 返回的函数 带 bound 前缀

```js
const func = function func1() {};
console.log(func.bind(null).name); //bound func1
```

## 函数 length 属性

表示函数写的形参个数,注意不包括默认值可剩余参数的个数

```js
const a = (a, b = 123, ...c) => {};
console.log(a.length); //1
```

### 函数调用

函数名后面加() 调用;

```js
func();
```

call apply 调用

```js
func.call(null);
```

还有一个特定于字符串模板的调用
func`aaa`
这个一般也用不到,会把字符串传递给函数来调用

Reflect.apply(func,this,arg)
等于 apply 很少用,以后的趋势

## 函数高级

### 执行上下文

表示一个运行环境,会被推入调用堆栈,其中记录当前运行的所有信息  
例如脚本开始就是一个全局执行上下文,然后函数调用会创建一个新的执行上下文
eval 也会创建一个,但是这个很少使用,也不建议使用
函数执行完毕后当前执行上下文出栈,同时销毁内部词法环境(有引用除外)  
引擎永远执行调用堆栈最上面的那个调用帧,执行栈为空时回去任务队列取新任务入栈

### 词法环境

每个执行上下文都包含一个词法环境对象,内部存储了可用变量 this 等声明集合  
每个词法环境都包含一个外部词法环境的引用,全局的外部引用是 null,以此来形成  
词法环境链,就是常说的作用域链
具体细节可以看规范,这里只是宏观描述

### 变量查找规则

当一个变量在内部环境找不到时,会向外寻找,只到全局词法环境也找不到就会报错  
所以内部作用域可以使用或者修改外部环境的变量值,反过来则不行
JS 中 全局 函数 代码块 都会创建一个词法环境

## 闭包

有了以上前置知识,下面来说闭包  
闭包可以说是 JS 最核心的特性了,很多功能都是基于闭包实现的;
有趣的是闭包在规范中是不存在这个名词的,这属于民间的一个叫法,每个语言  
又不甚相同,每个人理解的闭包也不同

### 什么是闭包

首先由于函数一等公民的缘故,所以函数可以在一个地方声明,多个不同环境调用  
为了能使多个环境都能与创建环境通讯,所以有了闭包特性
闭包是基于静态作用域的,闭包就是  
函数在创建时 会保存创建时词法环境的引用(规范说法是[[Environment]]内部属性),  
无论在什么环境运行,都会使用这个  
来作为外部词法环境 ,函数每次运行,都会创建一个新的执行上下文,会创建一个新的  
词法环境 内部词法环境每次都是新的,而外部词法环境永远是保存的创建时的词法环境

#### 例子 1

```js
let a = 123;
function func() {
  console.log(a);
}
function func1() {
  let a = 234;
  func();
}
func1(); // 123
```

由于 func 内部词法环境没有 a 变量,所以会向外寻找,函数是在全局词法环境创建的,  
所以寻找的是全局的 a 变量 自然就是 123;

#### 例子 2

```js
function fun1() {
  let a = 1;
  return () => {
    console.log(a);
  };
}
let a = 123;
fun1()(); //1
```

最明显的闭包了,函数在 fun1 里创建 自然寻找的内部的 a

## 闭包用途

看似简单的概念,在 js 中可以说是无处不在

### 1. 隐藏变量

Js 里没有类 只能用构造函数模拟类,而构造函数是没有私有变量的(es2020 有了),  
闭包可以模拟实现

```js
function Obj() {
  let a = 123;
  this.loga = function () {
    console.log(a);
  };
}
```

a 就作为私有变量了,,只能被实例访问,每个实例都有自己的状态

### 2. 函数记忆状态

函数运行也是需要状态的,但是内部环境每次都会初始化,  
而外部环境是不被初始化的,
举个最简单例子,一个函数如何打印调用次数出来?

```js
function func() {
  let a = 0;
  return function () {
    a += 1;
    console.log(`函数调用了${a}次`);
  };
}
```

你可能会想到,往函数身上挂载一个属性不也可以实现么,  
事实上,外部环境的引用就是函数身上的[[Environment]]这个内部属性保存的  
并且这个属性我们无法直接读取和更改

### 3. 共享闭包

既然外部词法环境就是一个对象,那么自然会有多个函数共同引用同一个环境

```js
function fun() {
  let a = 1;
  return {
    fun1() {
      console.log(a);
    },
    fun2() {
      a++;
    }
  };
}
const { fun1, fun2 } = fun();
fun1(); //1
fun2();
fun1(); //2
```

这种共享闭包是很多见的,这两个函数在同一个词法环境创建,自然是同一个闭包  
所以一个函数修改了闭包,也会反映到另一个函数中,  
**因为闭包是保存的环境对象的引用,而不是其中某个具体的值**
就像两个变量引用同一个对象,一个变量修改了内部属性,另一个变量也会改变

### 4. 消息通讯

这个可以属于算是解释为什么有闭包这个机制了,就是不同词法环境的通讯  
细想一下,既然**闭包可以访问创建时的环境,而参数和返回值可以和执行环境交互**  
这样不就实现了不同环境的消息通讯了么?这两个特性组合可以形成各种数据交互
最常用的就是嵌套函数,举个刻意的例子,给函数绑定一个参数

```js
function func(data, fun) {
  let a = 123;
  return function () {
    fun(data + a);
  };
}
```

此函数接收两个参数,这两个参数都是执行环境提供的,然后返回给执行环境一个新函数,  
这个新函数把传入得数据作为闭包保存了,这是因为**参数也属于词法环境**的值.

### 垃圾收集

正常来说,函数运行完毕后 ,本次运行所创造的内部词法环境会被回收
但是如果有别的函数引用了这个环境 ,而这个函数可以被访问到(例如返回函数)
根据标记清除原理 那么这个环境就不会消失
这也是闭包能实现的前提

### 浏览器所做的优化

按照规范,每个函数都会保存外部词法环境的引用,但是这样实在是有点不合理
例如 内部函数根本不使用外部变量 那么保存这个环境就属于资源浪费了
所以引擎基本都优化掉了这个闭包,正常使用不会产生任何影响

```js
function func() {
  let a = 123;
  return function () {
    debugger;
  };
}
func()();
```

此时如果在控制台手动打印 a 变量
Chrome: 变量不存在
<img src="img/close-chorme.png"/>

火狐浏览器会提示 该变量已被优化掉

<img src="img/fier.png"/>

## 柯里化

柯里化是指将一个多个参数的函数,转换为单个参数的形式,返回的是一个新的函数

```js
func(a,b,c) => func(a)(b)(c)
```

这属于函数式编程的基本操作了,因为我们有时候这个函数的参数无法一次性传递完成  
所以我们可以先传一部分参数,然后返回一个绑定了这个参数的函数供等剩余参数准备好后  
再传递,内部也是利用闭包的机制,例如你调用一个库方法,这个方法接收三个参数
而你的前两个参数是固定的,这时你如果每次传入三个参数会很麻烦,这时就可以固定前两个  
参数,每次只传最后一个参数即可

## 总结

js 的各种灵活性都是由函数一等公民的特性实现的
