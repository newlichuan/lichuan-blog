---
id: 函数高级
title: 函数高级
author: 李川
author_title: 随便写写
author_url: https://github.com/newlichuan
author_image_url: /img/logo.jpg
---

#### 函数高级....

<!--truncate-->

## 执行上下文

表示一个运行环境,会被推入调用堆栈,其中记录当前运行的所有信息  
例如脚本开始就是一个全局执行上下文,然后函数调用会创建一个新的执行上下文  
函数执行完毕后当前执行上下文出栈,全局执行上下文到页面关闭才结束
引擎永远执行调用堆栈最上面的那个调用帧

## 词法环境

每个执行上下文都有两个词法环境对象,

#### 一个是内部词法环境

用于保存当前作用域可用的变量集合 ,包括 this 等,

#### 一个是外部词法环境的引用,

保存创建时所在的词法环境

#### 变量查找规则

当一个变量在内部环境找不到时,会向外寻找,只到全局词法环境也找不到就会报错  
所以内部作用域可以使用或者修改外部环境的变量值,反过来则不行
JS 中 全局 函数 代码块 都会创建一个词法环境
一个内部环境可以是另一个环境的外部环境 层层嵌套
**环境是链式的 所以也叫作用域链**

## 闭包

有了以上前置知识,下面来说闭包  
闭包可以说是 JS 最核心的特性了,很多功能都是基于闭包实现的;

### 什么是闭包

闭包是基于静态作用域的,闭包就是  
函数在创建时 会保存创建时词法环境的引用,无论在什么环境运行,都会使用这个  
来作为外部词法环境 ,函数每次运行,都会创建一个新的执行上下文,会创建一个新的  
词法环境 内部词法环境每次都是新的,而外部词法环境永远是保存的创建时的词法环境

#### 例子 1

```js
let a = 123;
function func() {
  console.log(a);
}
function func1() {
  let a = 234;
  func();
}
func1(); // 123
```

由于 func 内部词法环境没有 a 变量,所以会向外寻找,函数是在全局词法环境创建的,  
所以寻找的是全局的 a 变量 自然就是 123;

#### 例子 2

```js
function fun1() {
  let a = 1;
  return () => {
    console.log(a);
  };
}
let a = 123;
fun1()(); //1
```

最明显的闭包了,函数在 fun1 里创建 自然寻找的内部的 a

## 闭包用途

看似简单的概念,在 js 中可以说是无处不在

### 1. 隐藏变量

Js 里没有类 只能用构造函数模拟类,而构造函数是没有私有变量的(es2020 有了),  
闭包可以模拟实现

```js
function Obj() {
  let a = 123;
  this.loga = function () {
    console.log(a);
  };
}
```

a 就作为私有变量了,,只能被实例访问,每个实例都有自己的状态

### 2. 保存自己状态

函数运行也是需要状态的,但是内部环境每次都会初始化,  
而外部环境是不被初始化的,
举个最简单例子,一个函数如何打印调用次数出来?

```js
function func() {
  let a = 0;
  return function () {
    a += 1;
    console.log(`函数调用了${a}次`);
  };
}
```

你可能会想到,往函数身上挂载一个属性不也可以实现么,  
事实上,外部环境的引用就是函数身上的[[Environment]]这个内部属性保存的  
并且这个属性无法读取和更改

### 3. 共享闭包

既然外部词法环境就是一个对象,那么自然会有多个函数共同引用同一个环境

```js
function fun() {
  let a = 1;
  return {
    fun1() {
      console.log(a);
    },
    fun2() {
      a++;
    }
  };
}
const { fun1, fun2 } = fun();
fun1(); //1
fun2();
fun1(); //2
```

这种共享闭包是很多见的,这两个函数在同一个词法环境创建,自然是同一个闭包  
所以一个函数修改了闭包,也会反映到另一个函数中,  
**因为闭包是保存的环境对象的引用,而不是其中某个具体的值**
就像两个变量引用同一个对象,一个变量修改了内部属性,另一个变量也会改变

### 4. 模块化

闭包特性就是模块化的代表,一个模块返回一个函数  
该函数可以在任何环境导入来运行,并且依赖函数参数和返回值和闭包  
来实现不同环境的消息通讯,其实 es6 之前 ,就是拿立即执行函数来模拟模块化的

## 垃圾收集

正常来说,函数运行完毕后 ,本次运行所创造的内部词法环境会被回收  
但是如果有别的函数引用了这个环境 ,而这个函数可以被访问到(例如返回函数)  
根据标记清除原理 那么这个环境就不会消失  
这也是闭包能实现的前提

## 浏览器所做的优化

按照规范,每个函数都会保存外部词法环境的引用,但是这样实在是有点不合理  
例如 内部函数根不不使用外部变量 那么保存这个环境就属于资源浪费了  
所以引擎基本都优化掉了这个闭包,正常使用不会产生任何影响

```js
function func() {
  let a = 123;
  return function () {
    debugger;
  };
}
func()();
```

此时如果在控制台手动打印 a 变量
Chrome: 变量不存在
<img src="img/close-chorme.png"/>

火狐浏览器会提示 已被优化掉

<img src="img/fier.png"/>

## 总结

写的有点乱,对闭包的使用也是停留在最基本的阶段,多多扩展吧
