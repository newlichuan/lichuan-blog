---
id: 作用域和闭包
title: 作用域和闭包
author: 李川
author_title: 随便写写
author_url: https://github.com/newlichuan
author_image_url: /img/logo.jpg
---

#### JS 的基础运行机制

<!--truncate-->

### 执行上下文

代码执行的环境,其中记录当前运行的所有信息,浏览器用栈结构管理
例如脚本开始就是一个全局执行上下文,然后函数调用会创建一个新的执行上下文
eval 也会创建一个,但是这个很少使用,也不建议使用
函数执行完毕后当前执行上下文出栈,同时销毁内部词法环境(有引用除外)  
引擎永远执行调用堆栈最上面的那个调用帧,执行栈为空时回去任务队列取新任务入栈

### 词法环境 作用域

每个执行上下文都包含一个词法环境对象,内部存储了可用变量 this 等声明集合  
每个词法环境都包含一个外部词法环境的引用,全局的外部引用是 null
以此来形成词法环境链,就是常说的作用域链

### 作用域可以理解为对象

其实作用域就是一个键值对组合,例如 with 语句就明确的表示将一个对象添加到作用域链最底层
而且全局词法环境的上层就是全局对象,

```js
with (obj) {
  a = 123;
}
```

### 变量查找规则

当一个变量在内部环境找不到时,会向外层作用域寻找,**注意是没有这个标识符,而不是有变量无值**
只到全局对象也找不到就会报错,所以内部作用域可以使用或者修改外部环境的变量值,反过来则不行
JS 中 全局 函数 代码块 都会创建一个作用域

### 闭包

闭包可以理解为函数创建作用域链的规则,以上前置可知 每个作用域链都有一个父级属性,而函数执行会创建一个新的作用域,那么这个新的作用域父级该是哪个呢?是创建时还是运行时呢,其实无论从哪方面考虑,**使用创建时都更为合理**,
所以引出以下规则就是 函数创建时身上会保留创建作用域的引用,调用时会以这个引用为父级创建新的作用域,
再加上垃圾回收的规则,不可达的引用会被回收,所以只要函数存在,他保存的作用域也存在

### 举几个例子

举例说明一下闭包的几个特性

#### 例子 1

```js
let a = 123;
function func() {
  console.log(a);
}
function func1() {
  let a = 234;
  func();
}
func1(); // 123
```

由于 func 内部词法环境没有 a 变量,所以会向外寻找,函数是在全局词法环境创建的,所以外部环境就是全局,  
所以寻找的是全局的 a 变量 自然就是 123;

#### 例子 2

```js
function fun1() {
  let a = 1;
  return () => {
    console.log(a);
  };
}
let a = 123;
fun1()(); //1
```

最明显的闭包了,函数在 fun1 里创建 自然寻找的内部的 a 同时这个对象不会被回收

### 闭包用途

看似简单的概念,在 js 中可以说是无处不在

### 1. 隐藏变量

Js 里没有类 只能用构造函数模拟类,而构造函数是没有私有变量的(es2020 有了),  
闭包可以模拟实现

```js
function Obj() {
  let a = 123;
  this.loga = function () {
    console.log(a);
  };
}
```

a 就作为私有变量了,,只能被实例访问,每个实例都有自己的状态

### 2. 函数记忆状态

函数运行也是需要状态的,但是内部环境每次都会初始化,  
而外部环境是不被初始化的,
举个最简单例子,一个函数如何打印调用次数出来?

```js
function func() {
  let a = 0;
  return function () {
    a += 1;
    console.log(`函数调用了${a}次`);
  };
}
```

你可能会想到,往函数身上挂载一个属性不也可以实现么,  
事实上,外部环境的引用就是函数身上的[[Environment]]这个内部属性保存的,并且这个属性我们无法直接读取和更改
而往函数身上挂属性,则可以被别人修改

### 3. 共享闭包

既然外部词法环境就是一个对象,那么自然会有多个函数共同引用同一个环境

```js
function fun() {
  let a = 1;
  return {
    fun1() {
      console.log(a);
    },
    fun2() {
      a++;
    }
  };
}
const { fun1, fun2 } = fun();
fun1(); //1
fun2();
fun1(); //2
```

这种共享闭包是很多见的,这两个函数在同一个词法环境创建,自然是同一个闭包  
所以一个函数修改了闭包,也会反映到另一个函数中,  
**因为闭包是保存的环境对象的引用,而不是其中某个具体的值**
就像两个变量引用同一个对象,一个变量修改了内部属性,另一个变量也会改变

### 4. 消息通讯

这个可以属于算是解释为什么有闭包这个机制了,就是不同词法环境的通讯  
细想一下,既然**闭包可以访问创建时的环境,而参数和返回值可以和执行环境交互**  
这样不就实现了不同环境的数据互通了么?这两个特性组合可以形成各种数据交互
最常用的就是嵌套函数,举个刻意的例子,给函数绑定一个参数

```js
function func(data, fun) {
  let a = 123;
  return function () {
    fun(data + a);
  };
}
```

此函数接收两个参数,这两个参数都是执行环境提供的,然后返回给执行环境一个新函数,  
这个新函数把传入得数据作为闭包保存了,这是因为**参数也属于词法环境**的值.
而以前的模块本质就是个立即执行函数,也是这个机制

### 垃圾收集

正常来说,函数运行完毕后 ,本次运行所创造的内部词法环境会被回收
但是如果有别的函数引用了这个环境 ,而这个函数可以被访问到(例如返回函数)
根据标记清除原理 那么这个环境就不会消失
这也是闭包能实现的前提

### 浏览器所做的优化

按照规范,每个函数都会保存外部词法环境的引用,但是这样实在是有点不合理
例如 内部函数根本不使用外部变量 那么保存这个环境就属于资源浪费了
所以引擎的选择是通过分析这个函数 只保留需要用的变量,这是很有必要的.

```js
function func() {
  let a = 123;
  return function () {
    debugger;
  };
}
func()();
```

此时如果在控制台手动打印 a 变量
Chrome: 变量不存在
<img src="img/close-chorme.png"/>

火狐浏览器会提示 该变量已被优化掉

<img src="img/fier.png"/>

### 总结

js 运行的基本也是核心的概念,并不难,但是需要多多体会
